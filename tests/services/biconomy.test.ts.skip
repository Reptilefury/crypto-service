// Mock ethers before importing service
jest.mock('ethers', () => ({
  providers: {
    JsonRpcProvider: jest.fn()
  },
  Wallet: jest.fn(),
  utils: {
    hexlify: jest.fn().mockReturnValue('0x1234567890abcdef'),
    randomBytes: jest.fn().mockReturnValue(new Uint8Array(32)),
    getContractAddress: jest.fn().mockReturnValue('0xSmartAccountAddress'),
    parseUnits: jest.fn().mockReturnValue('1000000'),
    Interface: jest.fn().mockImplementation(() => ({
      encodeFunctionData: jest.fn().mockReturnValue('0xencoded')
    }))
  }
}));

jest.mock('@biconomy/account', () => ({
  BiconomySmartAccountV2: {
    create: jest.fn().mockResolvedValue({
      getAccountAddress: jest.fn().mockResolvedValue('0xSmartAccountAddress')
    })
  }
}));

import biconomyService from '../../src/services/biconomy';

describe('BiconomyService', () => {
  describe('getSmartAccountAddress', () => {
    it('should get smart account address', async () => {
      const userAddress = '0x123456789abcdef';

      const result = await biconomyService.getSmartAccountAddress(userAddress);

      expect(result.smartAccountAddress).toBeDefined();
      expect(result.bundlerUrl).toBeDefined();
    });
  });

  describe('executeTransaction', () => {
    it('should execute transaction successfully', async () => {
      const smartAccount = {
        address: '0x987654321fedcba',
        buildUserOp: jest.fn().mockResolvedValue({}),
        sendUserOp: jest.fn().mockResolvedValue({ userOpHash: '0xhash' })
      };
      const transaction = { to: '0x123', value: '1000000000000000000' };

      const result = await biconomyService.executeTransaction(smartAccount, transaction);

      expect(result.userOpHash).toBeDefined();
    });
  });

  describe('getBiconomyConfig', () => {
    it('should return biconomy configuration', () => {
      const config = biconomyService.getBiconomyConfig();

      expect(config.bundlerUrl).toBeDefined();
      expect(config.chainId).toBeDefined();
    });
  });
});
